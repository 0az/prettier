exports[`test async.js 1`] = `
"// @flow

// "For async functions, a Promise<T> is returned,
// and the type of return expressions must be T."
//

async function f0(): Promise<number> {
  return 1;
}

async function f1(): Promise<bool> {
  return 1;  // error, number != bool
}

// await: (p: Promise<T> | T) => T
//

async function f2(p: Promise<number>): Promise<number> {
  var x: number = await p;
  var y: number = await 1;
  return x + y;
}

async function f3(p: Promise<number>): Promise<number> {
  return await p;
}

// TODO: this is one of those bad generic errors, currently:
// "inconsistent use of library definitions" with two core.js locs
async function f4(p: Promise<number>): Promise<bool> {
  return await p; // error, number != bool
}

// async arrow functions
//

var f5: () => Promise<number> = async () => await 1;

// async methods
//

class C {
  async m() { return 1; }
  async mt<T>(a: T): Promise<T> { return a; }
  static async m(a): void { await a; } // error, void != Promise<void>
  static async mt<T>(a: T): Promise<T> { return a; }
}

// async function props

var obj = { f: async () => await 1 };
var objf : () => Promise<number> = obj.f;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// @flow
// "For async functions, a Promise<T> is returned,
// and the type of return expressions must be T."
//
// error, number != bool
// await: (p: Promise<T> | T) => T
//
// TODO: this is one of those bad generic errors, currently:
// "inconsistent use of library definitions" with two core.js locs
// error, number != bool
// async arrow functions
//
// async methods
//
// error, void != Promise<void>
// async function props
async function f0(): Promise<number> {
  return [object Number];
}
async function f1(): Promise<boolean> {
  return [object Number];
}
async function f2(p: Promise<number>): Promise<number> {
  var x: number = await p;
  var y: number = await [object Number];
  return x + y;
}
async function f3(p: Promise<number>): Promise<number> {
  return await p;
}
async function f4(p: Promise<number>): Promise<boolean> {
  return await p;
}
var f5: () => Promise<number> = async () => await [object Number];
class C {
  async m() {
    return [object Number];
  }
  async mt<T>(a: T): Promise<T> {
    return a;
  }
  static async m(a): void {
    await a;
  }
  static async mt<T>(a: T): Promise<T> {
    return a;
  }
}
var obj = { f: async () => await [object Number] };
var objf: () => Promise<number> = obj.f;
"
`;

exports[`test async_base_class.js 1`] = `
"// This is kind of weird, but it should parse. This works in babel without the
// parens around (await promise). From the es6 and async/await specs I (nmote)
// am not clear on whether it should. In any case it's a strange corner case
// that is probably not important to support.
class C {};

var P: Promise<Class<C>> = new Promise(function (resolve, reject) {
  resolve(C);
});

async function foo() {
  class Bar extends (await P) { }
  return Bar;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// This is kind of weird, but it should parse. This works in babel without the
// parens around (await promise). From the es6 and async/await specs I (nmote)
// am not clear on whether it should. In any case it's a strange corner case
// that is probably not important to support.
class C {}
var P: Promise<Class<C>> = new Promise(
  function(resolve, reject) {
    resolve(C);
  }
);
async function foo() {
  class Bar extends await P {}
  return Bar;
}
"
`;

exports[`test async_parse.js 1`] = `
"async function f() {}
async function ft<T>(a: T) {}

class C {
  async m() {}
  async mt<T>(a: T) {}
  static async m(a) {}
  static async mt<T>(a: T) {}
}

var e = async function () {};
var et = async function<T> (a: T) {};

var n = new async function() {};

var o = { async m() {} };
var ot = { async m<T>(a: T) {} };
var oz = { async async() {} };

var x = { async : 5 };
console.log(x.async);

var async = 3;
var y = { async };
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
async function f() {
  
}
async function ft<T>(a: T) {
  
}
class C {
  async m() {
    
  }
  async mt<T>(a: T) {
    
  }
  static async m(a) {
    
  }
  static async mt<T>(a: T) {
    
  }
}
var e = async function() {
  
};
var et = async function(a: T) {
  
};
var n = new async function() {
  
}();
var o = {
  async m() {
    
  }
};
var ot = {
  async m<T>(a: T) {
    
  }
};
var oz = {
  async async() {
    
  }
};
var x = { async: [object Number] };
console.log(x.async);
var async = [object Number];
var y = { async };
"
`;

exports[`test async_promise.js 1`] = `
"async function f(): Promise<number> {
  return Promise.resolve(1);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
async function f(): Promise<number> {
  return Promise.resolve([object Number]);
}
"
`;

exports[`test async_return_void.js 1`] = `
"// @flow

async function foo1(): Promise<string> {
  return;
}

async function foo2(): Promise<string> {
  return undefined;
}

async function foo3(): Promise<string> {
  function bar() { }
  return bar();
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// @flow
async function foo1(): Promise<string> {
  return;
}
async function foo2(): Promise<string> {
  return undefined;
}
async function foo3(): Promise<string> {
  function bar() {
    
  }
  return bar();
}
"
`;

exports[`test async2.js 1`] = `
"// @flow

// misc basic

function test1() {
  async function foo() {
    return 42;
  }

  async function bar() {
    var a = await foo();
    var b: number = a; // valid
    var c: string = a; // Error: number ~> string
  }
}

//
// void returns:
//

// inference should produce return type Promise<void>
// in the absence of an explicit return
//

function test2() {
  async function voidoid1() {
    console.log("HEY");
  }

  var voidoid2: () => Promise<void> = voidoid1; // ok

  var voidoid3: () => void = voidoid1; // error, void != Promise<void>
}

// annotated return type of Promise<void> should work
//

function test3() {
  async function voidoid4(): Promise<void> { // ok
    console.log("HEY");
  }
}

// other annotated return types should fail
// (note: misannotated return types with explicit
// return statements are covered in async.js)
//

function test4() {
  async function voidoid5(): void { // error, void != Promise<void>
    console.log("HEY");
  }
}

function test5() {
  async function voidoid6()
  : Promise<number> { // error, number != void
    console.log("HEY");
  }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// @flow
// misc basic
// valid
// Error: number ~> string
//
// void returns:
//
// inference should produce return type Promise<void>
// in the absence of an explicit return
//
// ok
// error, void != Promise<void>
// annotated return type of Promise<void> should work
//
// ok
// other annotated return types should fail
// (note: misannotated return types with explicit
// return statements are covered in async.js)
//
// error, void != Promise<void>
// error, number != void
function test1() {
  async function foo() {
    return [object Number];
  }
  async function bar() {
    var a = await foo();
    var b: number = a;
    var c: string = a;
  }
}
function test2() {
  async function voidoid1() {
    console.log("HEY");
  }
  var voidoid2: () => Promise<void> = voidoid1;
  var voidoid3: () => void = voidoid1;
}
function test3() {
  async function voidoid4(): Promise<void> {
    console.log("HEY");
  }
}
function test4() {
  async function voidoid5(): void {
    console.log("HEY");
  }
}
function test5() {
  async function voidoid6(): Promise<number> {
    console.log("HEY");
  }
}
"
`;

exports[`test async3.js 1`] = `
"// @flow

/**
 * test nested-promise unwrapping.
 * Note: currently we don't do this properly in the underlying
 * type of the Promise class, which causes spurious errors to
 * be raised here. Once that's fixed, the errors here will go
 * away.
 */

async function foo() {
  return 42;
}

async function bar() {
  return foo();
}

async function baz() {

  // a should now be typed as number, but is in fact
  // Promise<number> until nested-promise unwrap is fixed
  var a = await bar();

  // TODO this is valid code, but currently gives Promise ~> number error
  // due to lack of transitive Promise unwrap.
  var b: number = a;

  // should be number ~> string error, but currently gives
  // Promise ~> string error for the same reason
  var c: string = a;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// @flow
/**
 * test nested-promise unwrapping.
 * Note: currently we don't do this properly in the underlying
 * type of the Promise class, which causes spurious errors to
 * be raised here. Once that's fixed, the errors here will go
 * away.
 */
// a should now be typed as number, but is in fact
// Promise<number> until nested-promise unwrap is fixed
// TODO this is valid code, but currently gives Promise ~> number error
// due to lack of transitive Promise unwrap.
// should be number ~> string error, but currently gives
// Promise ~> string error for the same reason
async function foo() {
  return [object Number];
}
async function bar() {
  return foo();
}
async function baz() {
  var a = await bar();
  var b: number = a;
  var c: string = a;
}
"
`;

exports[`test await_not_in_async.js 1`] = `
"// note: currently, await-within-async enforcement is a
// done by the parser, which bails after a single error.

function f() {
  await 1;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// note: currently, await-within-async enforcement is a
// done by the parser, which bails after a single error.
function f() {
  await;
  [object Number];
}
"
`;

exports[`test await_not_in_async2.js 1`] = `
"// note: currently, await-within-async enforcement is a
// done by the parser, which bails after a single error.

function f(x) { return x; }

f(await 1);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// note: currently, await-within-async enforcement is a
// done by the parser, which bails after a single error.
function f(x) {
  return x;
}
f(await);
"
`;

exports[`test await_not_in_async3.js 1`] = `
"// note: currently, await-within-async enforcement is a
// done by the parser, which bails after a single error.

async function f(x) { return x; }

f(await 1);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// note: currently, await-within-async enforcement is a
// done by the parser, which bails after a single error.
async function f(x) {
  return x;
}
f(await);
"
`;

exports[`test await_parse.js 1`] = `
"async function f() { await 1; }
async function ft<T>(a: T) { await 1; }

class C {
  async m() { await 1; }
  async mt<T>(a: T) { await 1; }
  static async m(a) { await 1; }
  static async mt<T>(a: T) { await 1; }
}

var e = async function () { await 1; };
var et = async function<T> (a: T) { await 1; };

var n = new async function() { await 1; };

var o = { async m() { await 1; } };
var ot = { async m<T>(a: T) { await 1; } };
var oz = { async async(async) { await async; } };

var x = { await : 5 };
console.log(x.await);

var await = 3;
var y = { await };
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
async function f() {
  await [object Number];
}
async function ft<T>(a: T) {
  await [object Number];
}
class C {
  async m() {
    await [object Number];
  }
  async mt<T>(a: T) {
    await [object Number];
  }
  static async m(a) {
    await [object Number];
  }
  static async mt<T>(a: T) {
    await [object Number];
  }
}
var e = async function() {
  await [object Number];
};
var et = async function(a: T) {
  await [object Number];
};
var n = new async function() {
  await [object Number];
}();
var o = {
  async m() {
    await [object Number];
  }
};
var ot = {
  async m<T>(a: T) {
    await [object Number];
  }
};
var oz = {
  async async(async) {
    await async;
  }
};
var x = { await: [object Number] };
console.log(x.await);
var await = [object Number];
var y = { await };
"
`;
